I"√F<p>Dispositivos de entrada e sa√≠da (do Ingl√™s, <em>input</em> e <em>output</em>, IO) s√£o meios que computadores utilizam para se comunicar com o mundo externo. Opera√ß√µes de <em>entrada</em> s√£o meios em que programas recebem dados no sistema enquanto que opera√ß√µes de  <em>sa√≠da</em> s√£o formas de enviar dados pelo sistema. Al√©m das opera√ß√µes de entrada e sa√≠da, h√° tamb√©m os dispositivos de entrada e sa√≠da, como por exemplo, um teclado que se comunica com o seu computador, enviando dados a cada tecla pressionada, ou um impressora, que recebe dados para que sejam impressos em um papel.</p>

<p>Desde a leitura de um byte na mem√≥ria at√© acesso a um site de rede social na internet s√£o fortemente baseados em opera√ß√µes de entrada e sa√≠da. Neste cap√≠tulo, vamos focar nos mecanismos que a linguagem de programa√ß√£o nos fornece para fazer manipula√ß√µes de entrada e sa√≠da. No entanto, para uma mais profunda descri√ß√£o sobre as etapas e os dispositivos envolvidos em um opera√ß√£o de entra e sa√≠a, recomendo a leitura do livro do Andrew Tanenbaum, sobre sistemas operacionais.</p>

<h2 id="a-classe-file">A classe File</h2>

<p>A classe File √© o ponto de partida para realizer manipula√ß√µes de leitura e escrita em arquivos no disco. A classe File implementa v√°rios m√©todos que abstraem a complexidade de manipula√ß√£o de arquivos. Por exemplo, podemos usar o m√©todo <code class="language-plaintext highlighter-rouge">read</code> para ler um determinado arquivo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span> <span class="s2">"teste.txt"</span>
</code></pre></div></div>

<p>No exemplo acima, tentamos imprimir o conte√∫do do arquivo <code class="language-plaintext highlighter-rouge">teste.txt</code>. No entanto, esse programa retornar√° um erro (<code class="language-plaintext highlighter-rouge">No such file or directory</code>). Certifique-se que o arquivo <code class="language-plaintext highlighter-rouge">teste.txt</code> existe e est√° no mesmo diret√≥rio do nosso programa Ruby. Se voc√™ usa Linux ou similares, voc√™ pode usar o comando <code class="language-plaintext highlighter-rouge">echo</code> para imprimir uma string e o redirecionador  <code class="language-plaintext highlighter-rouge">&gt;</code> para enviar este conte√∫do para um arquivo. Por exemplo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"rosas s√£o vermelhas,
violetas s√£o azuis.
ruby √© massa,
mas ainda n√£o me seduz."</span> <span class="o">&gt;</span> poema.txt
</code></pre></div></div>

<p>O resultado desta opera√ß√£o <code class="language-plaintext highlighter-rouge">File.read "teste.txt"</code> √© uma √∫nica String com todo o conte√∫do do arquivo. Como nossa tinha v√°rias linhas, o m√©todo <code class="language-plaintext highlighter-rouge">read</code> identificou essas quebras de linhas e as substituiu por v√°rios <code class="language-plaintext highlighter-rouge">\n</code>, que √© o caractere utilizado para identificar uma quebra de linha. Caso quis√©ssemos percorrer o arquivo, e imprimir seu conte√∫do da mesma forma que foi inserido (respeitando a quebra de linhas), ter√≠amos que identificar os caracteres <code class="language-plaintext highlighter-rouge">\n</code> para ent√£o separar a senten√ßas.</p>

<p>Poder√≠amos evitar esse trabalho e usar o m√©todo <code class="language-plaintext highlighter-rouge">readlines</code>, que em vez de retornar uma √∫nica String com todo o conte√∫do do arquivo, este retorna um Array, separando os elementos a cada quebra de linha (<code class="language-plaintext highlighter-rouge">\n</code>).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">File</span><span class="p">.</span><span class="nf">readlines</span> <span class="s2">"poema.txt"</span>
</code></pre></div></div>

<p>Perceba que o caractere <code class="language-plaintext highlighter-rouge">\n</code> n√£o √© removido da String, e nem √© nossa inten√ß√£o remove-lo, do contr√°rio, ter√≠amos que for√ßadamente adicionar uma outra forma de quebra de linha, para manter a formata√ß√£o do nosso texto.</p>

<p>Ler um arquivo usando o <code class="language-plaintext highlighter-rouge">readlines</code> tem agora o mesmo idioma de percorrer elementos de uma lista.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">linha</span> <span class="k">in</span> <span class="no">File</span><span class="p">.</span><span class="nf">readlines</span> <span class="s2">"poema.txt"</span>
  <span class="nb">puts</span> <span class="n">linha</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Assim, podemos usar o que aprendemos sobre Strings e fazer manipula√ß√µes no conte√∫do do nosso arquivo. Por exemplo, poder√≠amos deixar o texto mais elegante colocando a primeira letra como mai√∫scula (usando o m√©todo <code class="language-plaintext highlighter-rouge">capitalize</code>). Poder√≠amos tamb√©m alterar o texto do nosso poema (usando o m√©todo <code class="language-plaintext highlighter-rouge">sub</code>). Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">linha</span> <span class="k">in</span> <span class="no">File</span><span class="p">.</span><span class="nf">readlines</span> <span class="s2">"poema.txt"</span>
  <span class="k">if</span> <span class="n">linha</span><span class="p">.</span><span class="nf">start_with?</span> <span class="s2">"mas"</span>
    <span class="n">linha</span> <span class="o">=</span> <span class="n">linha</span><span class="p">.</span><span class="nf">sub</span> <span class="s2">"mas ainda n√£o me seduz"</span><span class="p">,</span> <span class="s2">"gosto mais do que cuscuz"</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="n">linha</span><span class="p">.</span><span class="nf">capitalize</span>
<span class="k">end</span>
</code></pre></div></div>

<p>No c√≥digo acima, n√≥s colocamos um <code class="language-plaintext highlighter-rouge">if</code> que verifica se a <code class="language-plaintext highlighter-rouge">linha</code> come√ßa com a String <code class="language-plaintext highlighter-rouge">mas</code>, ou seja, nosso ind√≠cio pra saber que √© a √∫ltima linha. Se for, fazemos uma substitui√ß√£o usando o m√©todo <code class="language-plaintext highlighter-rouge">sub</code>. Perceba que precisamos atribuir o retorno do m√©todo <code class="language-plaintext highlighter-rouge">sub</code> para a mesma vari√°vel linha. Porque devemos fazer isso? Se estiver confuso, experimente remover a re-atribui√ß√£o da vari√°vel e inspecione o resultado.</p>

<p>Por fim, imprimimos usando um <code class="language-plaintext highlighter-rouge">linha.capitalize</code> para garantir que a primeira letra de cada linha ser√° capitalizada.</p>

<p>H√° um problema no nosso c√≥digo, no entanto. Toda vez que lemos um arquivo, esse arquivo √© armazenado em mem√≥ria. Logo, ap√≥s realizarmos a leitura, precisamos tamb√©m fechar o arquivo. Mas qual √© a nossa refer√™ncia ao arquivo que abrimos? Usamos o <code class="language-plaintext highlighter-rouge">File.readlines</code> para ler as linhas dentro de um la√ßo, mas n√£o temos controle sobre o arquivo que abrimos, pois isso foi abstra√≠do pela classe <code class="language-plaintext highlighter-rouge">File</code>. Para que possamos fechar o arquivo, precisamos ter uma refer√™ncia a esse arquivo. Para isso, usamos o m√©todo <code class="language-plaintext highlighter-rouge">open</code> que, al√©m de abrir o arquivo, nos retorna uma refer√™ncia para o arquivo aberto.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"poema.txt"</span><span class="p">)</span>
<span class="n">f</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">linha</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">linha</span>
<span class="k">end</span>
<span class="n">f</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div></div>

<p>No caso do exemplo acima, a vari√°vel <code class="language-plaintext highlighter-rouge">f</code> guarda a refer√™ncia ao arquivo. Assim podemos l√™-lo (<code class="language-plaintext highlighter-rouge">f.each</code>) e fecha-lo (<code class="language-plaintext highlighter-rouge">f.close</code>). Mas qual existe algum problema em manter o arquivo aberto? H√° basicamente dois problemas: primeiro, se n√£o indicar o momento em que o arquivo ser√° fechado, perdemos as garantias das altera√ß√µes no arquivo se efetivarem, pois ficar√° a cargo do sistema operacional decidir quando o arquivo ser√° fechado ou n√£o. Um segundo problema √© que embora o sistema operacional consiga lidar com algumas centenas (ou at√© milhares) de arquivos abertos simultaneamente, cada arquivo que abrimos ocupa espa√ßo de mem√≥ria. Em ambientes com restri√ß√£o de mem√≥ria, ou ambientes em que buscamos otimizar o m√°ximo poss√≠vel, o custo de gerenciar arquivos sem utiliza√ß√£o pode impactar no desempenho da aplica√ß√£o. Logo, √© uma boa pr√°tica garantir que um arquivo que foi aberto ser√° fechado.</p>

<p>Para evitar eventuais esquecimentos com arquivos abertos (e s√≥ perceber depois quando a sua aplica√ß√£o que precisar navegar por todos os diret√≥rios do sistema de arquivos der algum erro), podemos usar o idioma de blocos, que fecha automaticamente o arquivo ap√≥s execu√ß√£o do bloco.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"io.txt"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">arquivo</span><span class="o">|</span>
<span class="n">f</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">linha</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">linha</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Perceba que ao usar o idioma de bloco, n√£o temos mais a refer√™ncia ao arquivo aberto. Depois de estudar m√©todos e blocos, pense como voc√™ poderia implementar o m√©todo <code class="language-plaintext highlighter-rouge">open</code> de forma que um bloco possa ser passado por par√¢metro e a refer√™ncia ao arquivo seja fechada ap√≥s a execu√ß√£o do bloco.</p>

<p>Para escrever em um arquivo, temos tamb√©m que primeiro abri-lo. A diferen√ßa, nesse caso, √© que precisamos informar o interesse de escrita no dado arquivo, passado pelo par√¢metro <code class="language-plaintext highlighter-rouge">"w"</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"log.txt"</span><span class="p">,</span> <span class="s2">"w"</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="n">f</span><span class="p">.</span><span class="nf">write</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="p">}</span>
</code></pre></div></div>

<h2 id="m√©todos-auxiliares">M√©todos auxiliares</h2>

<p>A classe File conta com diversos m√©todos auxiliares. Um dos quais √© o m√©todo <code class="language-plaintext highlighter-rouge">each_byte</code>, que retorna a representa√ß√£o em bytes de cada caracter do nosso texto. Outro m√©todo √© o <code class="language-plaintext highlighter-rouge">each_char</code>, que retorna cada caracter individualmente. Outros m√©todos importantes da classe File:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># renomear um arquico</span>
<span class="no">File</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="s2">"poema.txt"</span><span class="p">,</span> <span class="s2">"Poema.txt"</span><span class="p">)</span>
<span class="c1"># tamanho do arquivo em bytes</span>
<span class="no">File</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="s2">"poema.txt"</span><span class="p">)</span>
<span class="c1"># verifica se o arquivo existe</span>
<span class="no">File</span><span class="p">.</span><span class="nf">exists?</span><span class="p">(</span><span class="s2">"poema.txt"</span><span class="p">)</span>
<span class="c1"># retorna o nome do arquivo, sem o diret√≥rio</span>
<span class="no">File</span><span class="p">.</span><span class="nf">basename</span><span class="p">(</span><span class="s2">"/home/gustavo/poema.txt"</span><span class="p">)</span>
<span class="c1"># =&gt; "poema.txt"</span>
<span class="c1"># retorna o diret√≥rio do arquivo, sem o nome do arquivo</span>
<span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="s2">"/home/gustavo/poema.txt"</span><span class="p">)</span>
<span class="c1"># =&gt; "/home/gustavo/"</span>
<span class="c1"># verifica se √© arquivo ou diret√≥rio</span>
<span class="no">File</span><span class="p">.</span><span class="nf">directory?</span><span class="p">(</span><span class="s2">"poema.txt"</span><span class="p">)</span>
<span class="c1"># =&gt; false</span>
</code></pre></div></div>

<h2 id="manipulando-dados-tabulados">Manipulando dados tabulados</h2>

<h3 id="csv">CSV</h3>

<h3 id="json">JSON</h3>

<p>Mas o que podemos fazer se o arquivo for um pouco mais estruturado? Por exemplo, um JSON?</p>

<p>Para criar um arquivo JSON:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"json"</span>

<span class="k">def</span> <span class="nf">write_to_json</span>

  <span class="n">livros</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="n">livros</span><span class="p">[</span><span class="ss">:sapiens</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Sapiens: A Brief History of Humankind"</span>
  <span class="n">livros</span><span class="p">[</span><span class="ss">:mindset</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Mindset: The New Psychology of Success"</span>
  <span class="n">livros</span><span class="p">[</span><span class="ss">:metrics</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"The tyranny of Metrics"</span>

  <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"livros.json"</span><span class="p">,</span> <span class="s2">"w"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">arquivo</span><span class="o">|</span>
    <span class="n">arquivo</span><span class="p">.</span><span class="nf">write</span> <span class="n">livros</span><span class="p">.</span><span class="nf">to_json</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">write_to_json</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_from_json</span>
  <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"livros.json"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">json</span><span class="o">|</span>
    <span class="n">json</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">linha</span><span class="o">|</span>
      <span class="nb">puts</span> <span class="n">linha</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">read_from_json</span>
</code></pre></div></div>

<p>Mas como podemos fazer pra manipular esse arquivo?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"json"</span>

<span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span> <span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">read</span> <span class="p">(</span><span class="n">livros</span><span class="p">.</span><span class="nf">json</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="lendo-dados-da-web">Lendo dados da web</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>require 'open-uri'
URI.open("https://raw.githubusercontent.com/facebook/react/master/package.json")
</code></pre></div></div>

<h2 id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de fixa√ß√£o</h2>

<ul>
  <li>
    <p>Escreva um programa que liste todos os arquivos de formato de imagem no diret√≥rio corrente e nos seus subdiret√≥rios.</p>
  </li>
  <li>
    <p>Fa√ßa um programa que conte quais s√£o as tr√™s bibliotecas mais utilizadas por 20 projetos JavaScript do GitHub.</p>
  </li>
</ul>
:ET