I"»:<p><a href="/ruby-guide">Voltar ao come√ßo do guia</a></p>

<p>Principais caracter√≠sticas do paradigma funcional:</p>

<ol>
  <li>Imutabilidade</li>
  <li>Fun√ß√µes puras</li>
  <li>Fun√ß√µes de anonimas</li>
  <li>Fun√ß√µes de alta ordem</li>
  <li>Transpar√™ncia referencial</li>
  <li>Memoiza√ß√£o</li>
  <li>Idepontencia</li>
  <li>Currying</li>
  <li>Avalia√ß√£o pregui√ßosa</li>
</ol>

<h2 id="imutabilidade">Imutabilidade</h2>

<p>Um dos principais conceitos de programa√ß√£o funcional √© a id√©ia de que estados s√£o imut√°veis. Mas o que isso quer dizer? Em princ√≠pio, isso significa que uma vez um valor √© atribu√≠do a uma vari√°vel, n√£o √© pode fazer uma reatribui√ß√£o de valor para esta vari√°vel. Logo,</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># houve uma mudan√ßa no estado da vari√°vel x</span>
</code></pre></div></div>

<p>Em uma linguagem de funcional dita como pura, essa re-atribui√ß√£o de vari√°vel lanc√ßaria um erro. No entanto, √© poss√≠vel em Ruby. Como a linguagem n√£o fornece mecanismos para for√ßar imutabilidade por padr√£o, fica como uma boa pr√°tica para desenvolvedores exercitarem.</p>

<h2 id="fun√ß√µes-puras">Fun√ß√µes puras</h2>

<p>M√©todos tamb√©m podem mudar o estado de vari√°veis. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">a</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">}</span>
<span class="nb">puts</span> <span class="n">a</span>   <span class="c1"># =&gt; [1, 2, 3]</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">a</span><span class="p">.</span><span class="nf">reject!</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">}</span>
<span class="nb">puts</span> <span class="n">a</span>   <span class="c1"># =&gt; [1, 2]</span>
</code></pre></div></div>

<p>Podemos perceber que o comportamento do <code class="language-plaintext highlighter-rouge">reject!</code> √© diferente do <code class="language-plaintext highlighter-rouge">reject</code>, pois o primeiro muda o valor da vari√°vel <code class="language-plaintext highlighter-rouge">a</code> enquanto que o segundo n√£o muda (este, na realidade, devolve um novo array com os elementos necess√°rios). Como estudamos no cap√≠tulo sobre m√©todos, em Ruby usamos como conven√ß√£o uma exclama√ß√£o (<code class="language-plaintext highlighter-rouge">!</code>) ao fim do nome do m√©todo, quando queremos passar um aviso de <em>cuidado</em> ao desenvolvedor. Um dos motivos desse cuidado √© que estes m√©todos alterarem o comportamento da vari√°vel a qual eles operam. Mas, novamente, <em>cuidado</em>. H√° v√°rios m√©todos em Ruby que mudam estado e n√£o necess√°riamente tem uma exclama√ß√£o no seu nome. Exemplos incluem os m√©todos, shift, pop, clear, delete (e v√°rios outros) da classe Array.</p>

<p>O primeiro passo para programa√ß√£o funcional em Ruby √© conhecer quais m√©todos manipulam estado de vari√°veis.</p>

<h3 id="quais-s√£os-os-problemas-de-estados-mutaveis">Quais s√£os os problemas de estados mutaveis?</h3>

<p>Fun√ß√µes puras s√£o aquelas que n√£o mudam o estado de uma vari√°vel. Ou seja, dado uma determinada entrada, uma fun√ß√£o pura deve</p>

<h2 id="fun√ß√µes-an√¥nimas">Fun√ß√µes an√¥nimas</h2>

<p>Fun√ß√µes an√¥nimas, como o nome mesmo sugere, s√£o fun√ß√µes que n√£o tem um nome n√£o foi (nem ser√°) definido. Uma fun√ß√£o com nome pode ser descrita da seguinte forma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ola</span>
  <span class="nb">puts</span> <span class="s2">"oi pessoal"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>E chamando o nome da fun√ß√£o, <code class="language-plaintext highlighter-rouge">ola</code>, obtemos como sa√≠da a string <code class="language-plaintext highlighter-rouge">oi pessoal</code>. Uma fun√ß√£o an√¥nima com comportamento similar, pode ser feita da seguinte forma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meu_lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"oi pessoal"</span> <span class="p">}</span>
</code></pre></div></div>

<p>Perceba que a declara√ß√£o da fun√ß√£o come√ßa na palavra reservada <code class="language-plaintext highlighter-rouge">lambda</code>, e a refer√™ncia para a fun√ß√£o √© aramazenada na var√≠avel <code class="language-plaintext highlighter-rouge">meu_lambda</code>. Ou seja, uma chamada ao <code class="language-plaintext highlighter-rouge">meu_lambda</code> retorna somente a refer√™ncia para a fun√ß√£o an√¥mia, e n√£o a executa (como talvez fosse o esperado). Para de fato executa-a, precisamos chamar o m√©todo <code class="language-plaintext highlighter-rouge">call</code>, da seguinte forma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meu_lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"oi pessoal"</span> <span class="p">}</span>

<span class="n">meu_lambda</span>        <span class="c1"># =&gt; #&lt;Proc:0x00005563f10ec298 (irb):6 (lambda)&gt;</span>

<span class="n">meu_lambda</span><span class="p">.</span><span class="nf">call</span>   <span class="c1"># =&gt; oi pessoal</span>
</code></pre></div></div>

<p>Como qualquer fun√ß√£o, √© poss√≠vel tamb√©m passar par√¢metros para que sejam executados dentro da fun√ß√£o.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meu_lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">nome</span><span class="o">|</span>  <span class="nb">puts</span> <span class="s2">"oi </span><span class="si">#{</span><span class="n">nome</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>

<span class="n">meu_lambda</span><span class="p">.</span><span class="nf">call</span> <span class="s2">"Gustavo"</span>   <span class="c1"># =&gt; oi Gustavo</span>
</code></pre></div></div>

<p>Percebam que o conte√∫do de um lambda √© definido por um bloco (note as chaves (<code class="language-plaintext highlighter-rouge">{}</code>) no come√ßo e no fim do m√©todo), e n√£o por um <code class="language-plaintext highlighter-rouge">def</code> e um <code class="language-plaintext highlighter-rouge">end</code>.  Isso acontece pois lambdas s√£o implementados como blocos em Ruby. No entanto, n√£o s√£o os mesmos tipos de blocos que vimos no cap√≠tulo sobre m√©todos. Em Ruby, lambdas s√£o implementa√ß√µes do tipo <code class="language-plaintext highlighter-rouge">Proc</code>, por isso que recebemos o valor <code class="language-plaintext highlighter-rouge">Proc:0x00005563f10ec298</code> ao imprimir a refer√™ncia do objeto que guarda nossa vari√°vel <code class="language-plaintext highlighter-rouge">meu_lambda</code>. Um <code class="language-plaintext highlighter-rouge">Proc</code> difere de um bloco simplesmente pois objetos do tipo <code class="language-plaintext highlighter-rouge">Proc</code> podem ser armazenados em uma vari√°vel.</p>

<p>Por fim, perceba que <code class="language-plaintext highlighter-rouge">lambda</code>, em Ruby, √© apenas um alias para <code class="language-plaintext highlighter-rouge">proc</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meu_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"oi pessoal"</span> <span class="p">}</span>
<span class="n">meu_proc</span><span class="p">.</span><span class="nf">call</span>  <span class="c1"># =&gt; oi pessoal</span>

<span class="n">meu_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">nome</span><span class="o">|</span>  <span class="nb">puts</span> <span class="s2">"oi </span><span class="si">#{</span><span class="n">nome</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
<span class="n">meu_proc</span><span class="p">.</span><span class="nf">call</span> <span class="s2">"Gustavo"</span>   <span class="c1"># =&gt; oi Gustavo</span>
</code></pre></div></div>

<h2 id="fun√ß√µes-de-alta-ordem">Fun√ß√µes de alta ordem</h2>

<p>Com lambdas, linguagens funcionais ganham uma nova caracter√≠sticas, chamada fun√ß√µes de alta ordem. Essa caracter√≠stica permite que fun√ß√µes possam ser armazenadas em vari√°veis do programa, que percebemos ao fazermos nosso primeiro exemplo usando o <code class="language-plaintext highlighter-rouge">meu_lambda</code>. Se uma fun√ß√£o pode ser armazenada em uma vari√°vel, podemos tamb√©m passar a fun√ß√£o por par√¢metro para outro m√©todo. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Salario</span>

	<span class="k">def</span> <span class="nf">initialize</span>
		<span class="vi">@salario</span> <span class="o">=</span> <span class="mi">1000</span>
		<span class="vi">@bonificacao</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">salario</span><span class="o">|</span> <span class="n">salario</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">}</span>
	<span class="k">end</span>

	<span class="k">def</span> <span class="nf">calcular</span>
		  <span class="vi">@salario</span> <span class="o">+=</span> <span class="vi">@bonificacao</span><span class="p">.</span><span class="nf">call</span> <span class="vi">@salario</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="n">salario</span> <span class="o">=</span> <span class="no">Salario</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">puts</span> <span class="n">salario</span><span class="p">.</span><span class="nf">calcular</span>
</code></pre></div></div>

<p>Da mesma forma que podemos passar fun√ß√µes como par√¢metros, podemos tamb√©m retornar fun√ß√µes de outras fun√ß√µes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gerador_de_lambdas</span><span class="p">(</span><span class="n">multiplicador</span><span class="p">)</span>
    <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">num</span><span class="o">|</span> <span class="n">num</span> <span class="o">*</span> <span class="n">multiplicador</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">vezes_tres</span> <span class="o">=</span> <span class="n">gerador_de_lambdas</span> <span class="mi">3</span>

<span class="nb">puts</span> <span class="n">vezes_tres</span><span class="p">.</span><span class="nf">call</span> <span class="mi">4</span>
</code></pre></div></div>

<h2 id="recurs√£o">Recurs√£o</h2>

<h2 id="currying">Currying</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">greet</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="s2">"Hello </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
<span class="n">greet</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'World'</span><span class="p">)</span>
<span class="c1"># =&gt; "Hello World"</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">generic_greet</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">greeting</span><span class="p">,</span> <span class="nb">name</span><span class="o">|</span> <span class="s2">"</span><span class="si">#{</span><span class="n">greeting</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
<span class="n">generic_greet</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'Hi'</span><span class="p">,</span> <span class="s1">'SengMing'</span><span class="p">)</span>
<span class="c1"># =&gt; "Hi SengMing"</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">curried_generic_greet</span> <span class="o">=</span> <span class="n">generic_greet</span><span class="p">.</span><span class="nf">curry</span>
<span class="n">curried_generic_greet</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'Ahoy'</span><span class="p">).</span><span class="nf">call</span><span class="p">(</span><span class="s1">'SengMing'</span><span class="p">)</span>
<span class="c1"># =&gt; "Ahoy SengMing"</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hi_greet</span> <span class="o">=</span> <span class="n">curried_generic_greet</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'Hi'</span><span class="p">)</span>
<span class="n">hi_greet</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'SengMing'</span><span class="p">)</span>
<span class="c1"># =&gt; "Hi SengMing"</span>
</code></pre></div></div>
:ET